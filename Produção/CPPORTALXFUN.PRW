#Include "Protheus.Ch"
#Include "rwmake.ch"  
#include 'fileio.ch'
#include 'report.ch'
#Include "RPTDEF.CH"

#DEFINE EOL		CHR(13)+CHR(10)


/*

ͻ
Programa            Autor  Augusto Ribeiro      Data  09/02/2011  
͹
Desc.      Funcaoes Genericas utilizadas na Publicacao dos arquivos   
          do portal                                                   
                                                                      
ͼ

*/

/*

ͻ
Programa  omGerPdf  Autor  Augusto Ribeiro      Data  09/02/2011  
͹
Desc.     Imprime relatrio em PDF                                    
           *ATENCAO* - Necessario que o Action do rel. seja uma       
          User Function                                               
                                                                      
PARAMETROS oPrint      : Objeto do relatorio                          
           cPathName   : Caminho onde o PDF sera gerado               
           cNomeArq    : Nome do Arquivo                              
           cTipoRel    : Tipo de Relatorio TReport ou TMSPriter       
           cPDFPrinter : Nome da Impressora PDF utilizada             
                        Suporte *PDF995 ou CompilaPDF                 
                                                                      
RETORNO    aRet{lRelOK, cLOG_ERRO, P05_STATUS}                        
           1=Nao Processado;2=Processado;3=Inconsistencia;4=Desconsid 
͹
Uso        Zatix.	                                                  
ͼ

*/
User Function omGerPdf(oPrint, cPathName, cNomeArq, cPathServer,cTipoRel, cPDFPrinter, lPrintSrv)
Local aChkFile 		:= {}
Local cArqIniPdf		:= ""
Local nOutFile		:= 0
Local cPrintPadrao	:= ""
Local aRet				:= {.F., "","3"}
Local cSession		:= GetPrinterSession()     
Local nY				:= 0
Local nTimeOut		:= 600 	//| Segundos
Local cTempPath		:= ""
Local cTempExt		:= "pd_"

Local lPDFPrint    	:= .F. 
Local aPriters      

Local cPSConvert


Default lPrintSrv	:= .T.
Default cTipoRel	:= "TReport"   
Default cPathServer	:= cPathName
Default cPDFPrinter	:= "PDF995"

Private nHdlSemaf		:= 0	//| Semaforo
        
cTipoRel	:= UPPER(ALLTRIM(cTipoRel))			
cPDFPrinter	:= UPPER(cPDFPrinter)

	CONOUT("********| INICIO - omGerPdf - "+cPathName)

//Ŀ
// Verifica se a impressora est instalada 
//
aPriters		:= GetImpWindows(lPrintSrv)
For nY	:= 1 to LEN(aPriters) 
	IF upper(alltrim(aPriters[nY])) == cPDFPrinter
		lPDFPrint	:= .T.  
		exit
	ENDIF	
Next nY     
       

//Ŀ
// Configura Impressora PDF 
//
IF lPDFPrint
	IF cPDFPrinter == "PDF995"
		lPDFPrint := PDF995("A", nTimeOut, cPathName, cNomeArq)	
	
	ELSEIF cPDFPrinter == "COMPILAPDF"
	                                                               
		lPDFPrint := COMPILAPDF("A", nTimeOut, cPathName, cNomeArq, cPathServer, @nHdlSemaf)
	       
		//Ŀ
		// Fecha semaforo caso esteja aberto 
		//
		IF !(lPDFPrint) .AND. nHdlSemaf > 0
			FechaSemaf(nHdlSemaf)
		ENDIF
	ENDIF                      
ENDIF

IF lPDFPrint                 
	//Ŀ
	// Guarda impressao padrao.									         	 
	//
    //cPrintPadrao := GetProfString( cSession, "DEFAULT","",.T.)
	
	//Ŀ
	// Seta impressora de PDF como padrao.							         	 
	//
	WriteProfString( cSession , "DEFAULT", cPDFPrinter, .T. )
	
	//Ŀ
	// Define impressao Local no Client.							         	 
	//
	if lPrintSrv
		IF ALLTRIM(GetClientIP()) == ALLTRIM(GetServerIP())		
			WriteProfString( cSession , "LOCAL", "CLIENT", .T. )
		ELSE
			WriteProfString( cSession , "LOCAL", "SERVER", .T. )
		ENDIF
	else
		WriteProfString( cSession , "LOCAL", "CLIENT", .T. )
	endif
	
	//Ŀ
	// Define impressora com  orientacao do relatorio	   	 
	//
	IF oPrint:GetOrientation() == 1
//		WriteProfString( cSession , "ORIENTATION", "PORTRAIT", .T. )
	ELSE
//		WriteProfString( cSession , "ORIENTATION", "LANDSCAPE", .T. ) 
	ENDIF
	

	IF cTipoRel == "TREPORT"			
		//Ŀ
		// Dispara impressao do Relatorio  
		//	
		oPrint:SetEnvironment("SERVER")	//| {"SERVER","CLIENT"}
		oPrint:SetDevice("SPOOL")		//| {"FILE","SPOOL","PORT","EMAIL"}						
		oPrint:SetPreview(.F.) 
		oPrint:lParamPage	:= .F.	 
		
		oPrint:Print()	
		
		//Ŀ
		// Evita gerar arquivo com o mesmo nome.						         	 
		// 
		nOutPrinting	:= 0
		While oPrint:Printing()
			Sleep(250)	//| 0,25 Segundos  
			nOutPrinting++
			CONOUT("********| Printing "+alltrim(str(nOutPrinting))) 
			IF nOutPrinting >= 200
				EXIT
			ENDIF
		ENDDO
        
		//Ŀ
		// Verifica se o arquivo impresso est vazio 
		//
        IF oPrint:NXLSROW <= 3
	        aRet	:= {.F., "Nao ha dados a serem exibidos.", "4"}
        ELSE             
	        aRet	:= {.T.,"","2"}
	   		Sleep(500)	//| 0,5 Segundos
	 	ENDIF
   		
	ELSEIF cTipoRel == "TMSPRINTER"
	
		oPrint:Print()		
		aRet	:= {.T.,"","2"}

		Sleep(3000)	//| 1 Segundos        
	ENDIF		                                            		

	//Ŀ
	// Aguarda Termino da impressao do relatorio e fecha configurao da Impressora 
	//
	IF cPDFPrinter == "PDF995"
		IF aRet[1]
			lPDFPrint := PDF995("F", nTimeOut, cPathName, cNomeArq)	
		ELSE                                                        
			PDF995("F", nTimeOut, cPathName, cNomeArq)			
		ENDIF	
		//Verificando se foi criado o arquivo PDF
		aRet[1] := FILE(cPathName+cNomeArq)
	ELSEIF cPDFPrinter == "COMPILAPDF"				                                                               
		IF aRet[1]
			aRet[1] := COMPILAPDF("F", nTimeOut, cPathServer, cNomeArq, cPathServer, @nHdlSemaf)
			IF !(aRet[1])
				aRet[3]	:= "3"
			ENDIF
		ELSE                                                                                     
			COMPILAPDF("F", nTimeOut, cPathServer, cNomeArq, cPathServer, @nHdlSemaf)		
		ENDIF
	ENDIF
	
	
/*------------------------------------------------------------|  Augusto Ribeiro - 06/05/2015
	Utiliza impressora do Protheus  
-------------------------------------------------------------------------------------------*/
ELSEIF cPDFPrinter == "PROTHEUS"

		cTempPath	:= GetTempPath()+"totvsprinter\"
		
		/*------------------------------------------------------------|  Augusto Ribeiro - 08/05/2015
			Necessario trocar a extencao do arquivo para evitar que o TotvsPrinter
			abra o arquivo apos impressao.
		-------------------------------------------------------------------------------------------*/
		cTempNome	:= LEFT(cNomeArq,LEN(cNomeArq)-3)+cTempExt

		//Ŀ
		// Dispara impressao do Relatorio  
		//	
		oPrint:SetEnvironment("CLIENT")	//| {"SERVER","CLIENT"}
		oPrint:nDevice := 6
		oPrint:SetPreview(.F.)
		 
		oPrint:lParamPage	:= .F.	 
		oPrint:nColSpace	:= 0
		//oPrint:cDIR		:= cPathName
		oPrint:cFile		:= cTempNome
		
		//oPrint:cPathPDF		:= "e:\temp\teste_augusto"

		
		//File2Printer("e:\temp\teste_augusto.pd_", "PDF")
		oPrint:Print(.f.)	
		
		//Ŀ
		// Evita gerar arquivo com o mesmo nome.						         	 
		// 
		nOutPrinting	:= 0
		While oPrint:Printing()
			Sleep(250)	//| 0,25 Segundos  
			nOutPrinting++
			CONOUT("********| Printing "+alltrim(str(nOutPrinting))) 
			IF nOutPrinting >= 200
				EXIT
			ENDIF
		ENDDO
        
		//Ŀ
		// Verifica se o arquivo impresso est vazio 
		//
        IF oPrint:NXLSROW <= 3
	        aRet	:= {.F., "Nao ha dados a serem exibidos.", "4"}
        ELSE             
	       aRet	:= {.T.,"","2"}
			
			IF FILE(cTempPath+cTempNome+"."+cTempExt)	       
     
	       	__CopyFile(cTempPath+cTempNome+"."+cTempExt, cPathName+cNomeArq)
	       	
	       	FERASE(cTempPath+cTempNome+"."+cTempExt)
	       	FERASE(cTempPath+cTempNome+".rel")
	       	FERASE(cTempPath+cNomeArq)	       	
	       	
	       ELSE
	       	aRet	:= {.F., "Arquivo PDF nao encontrado.", "3"}
	       ENDIF

	   		//Sleep(500)	//| 0,5 Segundos
	 	ENDIF
	

ELSE
//	MSGBOX("Impressora PDF no encontrada - (PDF995 ou CompilaPDF)"+EOL+"Entre em contato com o TI.", "Impressora PDF no instalada", "ALERT")
	Conout("**ERRO**| Impressora PDF no encontrada - (PDF995 ou CompilaPDF)")
ENDIF  

CONOUT("********| FIM - omGerPdf - "+cPathName)
 
Return(aRet)   
                

                              
/*

ͻ
Programa   PDF995   Autor  Augusto Ribeiro      Data  09/02/2011  
͹
Desc.      Parametriza Impressora PDF995                              
                                                                      
PARAMETROS cAcao   : A = Abre Configuracao, F = Fecha Configuracao    
                                                                      
ͼ

*/
Static Function PDF995(cAcao, nTimeOut, cPathName, cNomeArq, lLocal)
Local lRet	:= .F.   
Local nTOut := 300 //| Segundos                       
Local cDirProg, cArqIniPdf, cPSConvert

Default nTimeOut := 60 //| Segundos
Default lLocal   := .F.

cDirProg 		:= GetEnv("ProgramFiles")                    

cArqIniPdf		:= alltrim(cDirProg)+"\pdf995\res\pdf995.ini"
cPSConvert		:= alltrim(cDirProg)+"\pdf995\res\drivedir\PSConvert.exe"    

//tratamento para (x86)
IF !(FILE(cPSConvert))
	cDirProg	:= REPLACE(UPPER(cDirProg)," (X86)","")

	cArqIniPdf		:= alltrim(cDirProg)+"\pdf995\res\pdf995.ini"
	cPSConvert		:= alltrim(cDirProg)+"\pdf995\res\drivedir\PSConvert.exe"    
	
	//Validao para Windows XP - Quando  windows XP a getenv
	IF !(FILE(cPSConvert))
		cDirProg	:= Upper("C:\Arquivos de Programas")
		
		cArqIniPdf		:= alltrim(cDirProg)+"\pdf995\res\pdf995.ini"
		cPSConvert		:= alltrim(cDirProg)+"\pdf995\res\drivedir\PSConvert.exe"    
	endif	
ENDIF 

//
//Configura Impressora 
//
IF cAcao == "A"

	If FILE(cArqIniPdf)

		//Ŀ
		// Apaga ini da PDF995 para evitar que seja gera arquivo com nome incorreto 
		//
		IF IF(FILE(cArqIniPdf), FERASE( cArqIniPdf )  == 0,.T.)                             
		
			//Ŀ
			// Altera o INI para comando de impressao.						         	 
			//
			nOutFile := MSFCreate(cArqIniPdf)
			
			FWrite(nOutFile,"[Parameters]"							+Chr(10))
			FWrite(nOutFile,"Quiet=0" 									+Chr(10))
			FWrite(nOutFile,"Install=1" 								+Chr(10))
			FWrite(nOutFile,"Use GPL Ghostcript=1" 				+Chr(10))
			FWrite(nOutFile,"Output File="+cPathName+cNomeArq	+Chr(10))
			FWrite(nOutFile,"Autolaunch=0" 						+Chr(10))   
			FWrite(nOutFile,"Document Name=Totvs Document" 		+Chr(10))  
			FWrite(nOutFile,"Default A4=1"				 		+Chr(10))   
			FWrite(nOutFile,"User File="+cPathName+cNomeArq		+Chr(10))   
			
			FClose(nOutFile)  
			
			lRet := .T.
		ENDIF
	ELSE
		//Ŀ
		// Altera o INI para comando de impressao.						         	 
		//
		nOutFile := MSFCreate(cArqIniPdf)
		
		FWrite(nOutFile,"[Parameters]"						+Chr(10))
		FWrite(nOutFile,"Quiet=0" 							+Chr(10))
		FWrite(nOutFile,"Install=1" 						+Chr(10))
		FWrite(nOutFile,"Use GPL Ghostcript=1" 				+Chr(10))
		FWrite(nOutFile,"Output File="+cPathName+cNomeArq	+Chr(10))
		FWrite(nOutFile,"Autolaunch=0" 						+Chr(10))   
		FWrite(nOutFile,"Document Name=Totvs Document" 		+Chr(10))  
		FWrite(nOutFile,"Default A4=1"				 		+Chr(10))   
		FWrite(nOutFile,"User File="+cPathName+cNomeArq		+Chr(10))   
		
		FClose(nOutFile)  
		
		lRet := .T.
	ENDIF
	              
//Ŀ
// Verifica se a impressao foi concluida e "Fecha" a  
//  a configurao da Impressora                      
//
ELSEIF cAcao == "F"

	//Ŀ
	//Verifica se a impresso j foi concluida 
	//
	While nTimeOut > 0
	
		IF fRENAME(cPSConvert, UPPER(cPSConvert)) == 0
			lRet	:= .T.
			EXIT
		ELSE
			Sleep(500)	//| 0,5 Segundos
		ENDIF
		
		nTimeOut--
		
		IF nTimeOut <= 0
			lRet := .F.
			EXIT
		ENDIF
	ENDDO  
	
	//Ŀ
	// Remove arquivo para evitar que outra aplicacao gere o PDF 
	// com o mesmo nome                                          
	//
	FERASE( cArqIniPdf )	
ENDIF

Return(lRet)



/*

ͻ
Programa   COMPILAPDFAutor Augusto Ribeiro      Data  12/02/2011  
͹
Desc.      Parametriza Impressora CompilaPDF                          
                                                                      
PARAMETROS cAcao   : A = Abre Configuracao e Semaforo                 
                   : F = Fecha Configuracao e Semaforo                
           nTimeOut, cPathName, cNomeArq, cPathServer                 
           nHdlSemaf : Handle do Semaforo alterado por referencia     
ͼ

*/            
Static Function COMPILAPDF(cAcao, nTimeOut, cPathName, cNomeArq, cPathServer, nHdlSemaf)
Local lRet	:= .F.                          
Local cDirProg, cArqIniPdf
Local cArqIniOrig 
Local nTime
Local nTimeMake		:= 10 //| Segundos, Timeout para criacao do PDF 
Local cFileSemaf	:= "pdf_compilapdf.lck"	//| Nome do Arquivo do Semaforo         
Local cLibPDF		:= ""

Default nTimeOut 	:= 60 //| Segundos
Default cPathServer	:= cPathName
Default nHdlSemaf	:= 0
	                            

	                                         
CONOUT("********| INICIO - COMPILAPDF - "+cAcao)	  

//
// Caminho abaixo do Protheus_data onde foi gerado o PDF 
//
cPathServer		:= cPathServer+cNomeArq
   /*
//| ORIGINAL - PROGRAM FILES
cDirProg 		:= GetEnv("ProgramFiles")                    
cDirProg		:= alltrim(cDirProg)+"\gs"
//
// Adapta caminho para 32 ou 64 bits 
// 
cArqIniPdf		:= cDirProg+"\pdfwrite.txt"
IF !(FILE(cArqIniPdf))
	cDirProg	:= REPLACE(UPPER(cDirProg),"(X86)","")
ENDIF
 */

cDirProg		:= U_AFAT151G("00", "PDFINSTALL") 

cArqIniPdf		:= cDirProg+"\pdfwrite.txt"
cArqIniOrig		:= cDirProg+"\pdfwrite_original.txt"

cFileSemaf		:= cDirProg+"\"+cFileSemaf

cLibPDF			:= cDirProg+"\gs\lib"

//
//Configura Impressora 
//
IF cAcao == "A" 

	//Ŀ
	// Abre Semaforo 
	//
	nHdlSemaf	:= AbreSemaf(cFileSemaf)  
	IF nHdlSemaf <= 0           
		Conout("********| Falha ao abrir Semaforo "+alltrim(cFileSemaf))
		Return(.F.)
	ENDIF				

	If FILE(cArqIniPdf)

		//Ŀ
		// Apaga ini  para evitar que seja gera arquivo com nome incorreto 
		//
		IF FERASE( cArqIniPdf )  == 0
		
			//Ŀ
			// Altera o INI para comando de impressao.						         	 
			//
			nOutFile := MSFCreate(cArqIniPdf)
					                  
//			FWrite(nOutFile,'-I"C:\Program Files\gs\gs8.71\lib";C:\Windows\Fonts'	+Chr(10))
			FWrite(nOutFile,'-I"'+cLibPDF+'";C:\Windows\Fonts'	+Chr(10))
			FWrite(nOutFile,' -sDEVICE=pdfwrite'									+Chr(10))
			FWrite(nOutFile,' -r600'												+Chr(10))
			FWrite(nOutFile,' -dNOPAUSE'											+Chr(10))
			FWrite(nOutFile,' -dSAFER'												+Chr(10))
			FWrite(nOutFile,' -sPAPERSIZE=a4'										+Chr(10))
			FWrite(nOutFile,' -dCompatibilityLevel=1.4'								+Chr(10))
			FWrite(nOutFile,' -dPDFSETTINGS=/prepress'								+Chr(10))
			FWrite(nOutFile,' -dAutoRotatePages=/PageByPage'						+Chr(10))
			FWrite(nOutFile,' -sOutputFile="'+cPathName+cNomeArq+'"'				+Chr(10))
			
			FClose(nOutFile)  
			
			lRet := .T. 
		ENDIF
	ELSE
		MSGBOX("Caminho da Impressora nao encontrado", "Impressora Nao Encontrada", "ALERT")
	ENDIF
	              
//Ŀ
// Verifica se a impressao foi concluida e "Fecha" a  
//  a configurao da Impressora                      
//
ELSEIF cAcao == "F"

	//Ŀ
	// Timeout para criacao do PDF 
	//
	FOR nTime := 1 TO nTimeMake
		IF FILE(cPathServer)
			EXIT          
		ELSE
			Sleep(500)	//| 0,5 Segundos
		ENDIF	       
	NEXT nTime
        
                            
	IF FILE(cPathServer)
		//Ŀ
		//Verifica se a impresso j foi concluida 
		//	
		FOR nTime := 1 TO nTimeOut
			  
		
			IF fRENAME(cPathServer, UPPER(cPathServer)) == 0
				lRet	:= .T.
				EXIT
			ELSE
				IF nTime >= nTimeOut
					lRet := .F.
					EXIT
				ENDIF			
				
				Sleep(500)	//| 0,25 Segundos
			ENDIF			
		NEXT nTime  		
	ELSE
		lRet := .F.		
	ENDIF
	
	//Ŀ
	// Remove arquivo para evitar que outra aplicacao gere o PDF 
	// com o mesmo nome                                          
	//
	FERASE( cArqIniPdf )                
		
	//Ŀ
	// Restaura Arquivo ini Original caso exista 
	//
	IF FILE(cArqIniOrig)
		__CopyFile(cArqIniOrig, cArqIniPdf)	
	ENDIF 
	
	//
	// Fecha Semaforo 
	//
	FechaSemaf(@nHdlSemaf, cFileSemaf)	
ENDIF
         
CONOUT("********| FIM - COMPILAPDF - "+cAcao)	  

Return(lRet)





/*

ͻ
Programa   omINqueryAutor  Augusto Ribeiro      Data  10/10/2006  
͹
Desc.      Recebe String ou  Array separa por caracter "X" ou Numero  
           de Caractres para "quebra" _nCaracX                        
                                                                      
PARAMETROS _xVar     : String ou Array                                
           _cCaracX  : Caracter para Quebra                           
           _nCaracX  : Numero de caracteres para Quebra               
                                                                      
RETORNO    Exemplo: ('A','C','F')                                     
ͼ

*/
User Function omINquery(_xVar, _cCaracX, _nCaracX)
Local _cRet	:= ""                  
Local _xVar, _cCaracX, _nCaracX, nY
Local _aString	:= {}                            
Default	_nCaracX := 0                   
		                              

		//
		// Caso dado enviado seja STRING 
		//
		IF ValType(_xVar) == "C" .AND. (!EMPTY(_cCaracX) .OR. _nCaracX > 0)
                                
	    	nString	:= LEN(_xVar)		
	
			//Ŀ
			// Utiliza Separacao por Numero de Caracteres 
			//
			IF _nCaracX > 0
				FOR nY := 1 TO nString STEP _nCaracX
				
					ADD(_aString, SUBSTR(_xVar,nY, _nCaracX) )
				
				Next nY
				
			//Ŀ
			// Utiliza Separacao por caracter especifico 
			//
			ELSE
				_aString	:= WFTokenChar(_xVar, _cCaracX)		
			ENDIF
		ENDIF		

		//
		//  Caso dado enviado seja ARRAY 
		//
		IF ValType(_xVar) == "A"  
			_aString	:= _xVar
		ENDIF
		   

		IF LEN(_aString) > 0
			//
			// Monta String para utilizar com IN em querys
			//
			_cRet	+=  "(
			FOR _nI := 1 TO Len(_aString)
		
				IF _nI > 1
					_cRet	+= ","
				ENDIF			

				IF VALTYPE(_aString[_nI]) == "C"
					_cRet	+=  "'"+ALLTRIM(_aString[_nI])+"'"
				ELSE                
					_cRet	+=  ALLTRIM(STR(_aString[_nI]))
				ENDIF
			Next _nI
			_cRet += ") " 
			 
		ENDIF
		
Return(_cRet) 


                                 
/*

ͻ
Programa  AbreSemaf Autor  Augusto Ribeiro      Data  28/02/2011  
͹
Desc.     Abre o Semafaro.                                            
ͼ

*/
Static Function AbreSemaf(cFile, nTimeOut )

Local nHdlSemaf	:= -1
Local nTimeOut

Default nTimeOut	:= 600 //| Segundos

nHdlSemaf := MSFCreate(cFile)
         
IF nHdlSemaf <= 0
   
	While nHdlSemaf <= 0
    
		nTimeOut--
	    IF nTimeOut <= 0
		    EXIT
	    ENDIF	    
		                              
		//Ŀ
		// Tenta Abrir Novamente 
		//
		Sleep(500)  
      
      	Conout("********| Abrindo Semaforo ("+alltrim(str(nTimeOut))+") "+cFile)
      
		nHdlSemaf := MSFCreate(cFile)
	EndDo         
    
ENDIF

Return(nHdlSemaf)


/*

ͻ
Programa  FechaSemafAutor  Augusto Ribeiro      Data  28/02/2011  
͹
Desc.     Fecha o Semafaro.                                           
ͼ

*/
Static Function FechaSemaf(nHdlSemaf, cFile)  
Local cFile                                   
Local nHdlSemaf

IF !(FCLOSE(nHdlSemaf))
   	Conout("**ERRO**| Falha ao Fechar Semaforo "+Str(FError(0)) )
ENDIF 

If ValType(cFile) == "C"
   Ferase(cFile)
EndIf   

Return()




/*

ͻ
Programa   omPubArq Autor  Augusto Ribeiro      Data  07/03/2010  
͹
Desc.      Publica arquivos no Portal                                 
           1. Copia Arquivo via FTP para Site                         
           2. Move Arquivo para Pasta Publicados                      
           3. Registra tabela de publicaca                            
                                                                      
PARAMETROS aRecnoP04   : Recno dos Arquivos                           
           cOpc        : "P" = "Publica", "R" = Remove                
                                                                      
RETORNO    aRet	:= {{lOK, Recno, cMsgErro}}    						  
ͼ

*/
User Function omPubArq(aRecnoP04, cOpc)
Local aRet		:= {}
Local aArea		:= GetArea()
Local aAreaP04	:= P04->(GetArea())
Local nY
Local lRet		:= .F.
Local cMsgErro	:= ""
Local aRecREMOVE	:= {}

Local cFTPURL, cFTPUser, cFTPPass, cFTPDir 
Local cDirGerado, cDirRemov, cDirPublic
Local cPathOrig, cPathDest, aRetDirFTP 
Local cQuery := ""

Default	cOpc := ""

//Ŀ
// Carrega Configuraes globais 
//
cFTPURL  	:= U_AFAT151G("00", "FTPPURL")
cFTPUser    := U_AFAT151G("00", "FTPPUSR")
cFTPPass	:= U_AFAT151G("00", "FTPPPAS")
cFTPDir		:= U_AFAT151G("00", "FTPPDIR")  

DBSELECTAREA("P04")
           



//
// REPROCESSAR                                                      
// Necessario remover todos os arquivos vinculados a nota fiscal    
// Esta query tem o objetivo de completar o array com os recnos dos 
// demais arquivos a serem removidos                                
//
IF cOpc == "4"	  

	//Ŀ
	// Executa 2 vezes a consulta para garantir que todo a estrutura 
	// de vinculo com a NF foi removida                              
	//
	FOR nI	:= 1 TO 2
	
			cQuery := " SELECT P04.R_E_C_N_O_ AS P04_RECNO "+EOL
			cQuery += " FROM "+RetSqlName("P05")+" P05 "+EOL
			cQuery += " INNER JOIN (SELECT P05_FILNF, P05_NOTA, P05_SERIE "+EOL
			cQuery += " 			FROM "+RetSqlName("P05")+" P05 "+EOL
			cQuery += " 			INNER JOIN "+RetSqlName("P04")+" P04 "+EOL
			cQuery += " 				ON P04.R_E_C_N_O_ in "+U_omINquery(aRecnoP04)
			cQuery += " 				AND P04_CODIGO = P05_CODARQ "+EOL
			cQuery += " 				AND P04.D_E_L_E_T_ = '' "+EOL
			cQuery += " 			WHERE P05_STATUS = '2' "+EOL
			cQuery += " 			AND P05.D_E_L_E_T_ = '' "+EOL
			cQuery += " 			GROUP BY P05_FILNF, P05_NOTA, P05_SERIE) A "+EOL
			cQuery += " 	ON A.P05_FILNF = P05.P05_FILNF "+EOL
			cQuery += " 	AND A.P05_NOTA = P05.P05_NOTA "+EOL
			cQuery += " 	AND A.P05_SERIE = P05.P05_SERIE "+EOL
			cQuery += " INNER JOIN "+RetSqlName("P04")+" P04 "+EOL
			cQuery += " 	ON P04.R_E_C_N_O_ NOT IN "+U_omINquery(aRecnoP04)
			cQuery += " 	AND P04_FILIAL = '' "+EOL
			cQuery += " 	AND P04_CODIGO = P05_CODARQ "+EOL
			cQuery += " 	AND P04.D_E_L_E_T_ = '' "+EOL
			cQuery += " WHERE P05.D_E_L_E_T_ = '' "+EOL
			cQuery += " GROUP BY P04.R_E_C_N_O_ "+EOL 
			
			If Select("REPR") > 0
				REPR->(DbCloseArea())
			EndIf                
			
			DBUseArea(.T.,"TOPCONN", TCGenQry(,,cQuery),"REPR", .F., .T.)
			
			WHILE REPR->(!EOF())	 
				
				AADD(aRecnoP04,REPR->P04_RECNO)
			
				REPR->(DBSKIP())
			ENDDO	
			REPR->(DbCloseArea())		
	NEXT nI
ENDIF




//Ŀ
// REPROCESSAR                                                   
// Arquivos com status aguardando publicacao devem ser removidos 
// sem a necessidade de conexao com o servidor FTP               
//   
IF cOpc == "4" .OR. cOpc == "3"

	FOR nY := 1 TO LEN(aRecnoP04)  
		IncProc("Processando...")		
	
		lRet		:= .F. 
		cMsgErro	:= ""
		
		P04->(DBGOTO(aRecnoP04[nY]))
		
		IF P04->P04_STATUS == "1"         
		
			cPathOrig	:= U_omPathPDF(P04->P04_STATUS)+alltrim(P04->P04_ARQUIV)
			cPathDest	:= U_omPathPDF(cOpc)+alltrim(P04->P04_ARQUIV)
				                                                                     
			//Ŀ
			// Copia Arquivo para pasta Removidos  
			//
			__CopyFile(cPathOrig , cPathDest)
				
			IF FILE(cPathDest)
			
				//Ŀ
				// Desabilita visualizacao do arquivo no Portal 
				//	
				RECLOCK("P04", .F.)
					P04->P04_STATUS := cOpc   
					IF EMPTY(P04->P04_DTREM)
						P04->P04_DTREM 	:= DDATABASE
						P04->P04_HRREM	:= TIME()
					ENDIF							
				MSUNLOCK()
				
				lRet	:= .T.		
				Ferase(cPathOrig)	//| Remove arquivo da pasta de origem
				
				U_PCON2EXP(,"P04", P04->(RECNO()), "U" )
			ELSE
				cMsgErro	:= "Falha ao mover arquivo para a Pasta Removidos"
			ENDIF	
	
			aadd(aRet, {lRet, aRecnoP04[nY], cMsgErro})				
		ELSE

			//Ŀ
			// Deixa no Array somente arquivos que devem ser removidos do Portal 
			//
			AADD(aRecREMOVE, aRecnoP04[nY])
		ENDIF		
	Next nY

	aRecnoP04	:= 	ACLONE(aRecREMOVE)
ENDIF

//Ŀ
// Conecta ao Servido FTP 
//                           
IF LEN(aRecnoP04) > 0
	IF FTPCONNECT( cFTPURL, /*porta*/, cFTPUser, cFTPPass )
		
		IF !EMPTY(cFTPDir)
			IF !(FTPDirChange(cFTPDir))
	
				cMsgErro	:= "Falha ao posicionar na Pasta do FTP: "+cFTPDir    
				aadd(aRet, {.F., 0, cMsgErro})					
			ENDIF
		ENDIF
	
		FOR nY := 1 TO LEN(aRecnoP04)  
	                                
			IncProc("Processando...")		
			
			lRet		:= .F.
			cMsgErro	:= ""
		
			P04->(DBGOTO(aRecnoP04[nY]))
	        
			//Ŀ
			// Publica Arquivos 
			//
			IF cOpc == "2" .AND. P04->P04_STATUS == "1"
	
				cPathOrig	:= U_omPathPDF(P04->P04_STATUS)+alltrim(P04->P04_ARQUIV)
				cPathDest	:= U_omPathPDF(cOpc)+alltrim(P04->P04_ARQUIV)			
					
				IF FTPUPLOAD(cPathOrig, alltrim(P04->P04_ARQUIV))
		
					//Ŀ
					// Verifica se arquivo realmente existe no destino 
					//
					//aRetDirFTP := FTPDIRECTORY( alltrim(P04->P04_ARQUIV), ) 			
					//IF LEN(aRetDirFTP) > 0
						
		
						//Ŀ
						// Copia Arquivo para pasta Publicados 
						//
						__CopyFile(cPathOrig , cPathDest)
						
						IF FILE(cPathDest)
							                         
							//Ŀ
							// Habilita visualizacao do arquivo no Portal 
							//
							RECLOCK("P04", .F.)
								P04->P04_DTPUBL := dDataBase
								P04->P04_HRPUBL := Time()
								P04->P04_STATUS := cOpc							
							MSUNLOCK()                
	
							lRet	:= .T.
	
							Ferase(cPathOrig)	//| Remove arquivo da pasta de origem
							
							/*-----------------------------------
								PROTHEUS CONNECTOR
							-------------------------------------*/							
							U_PCON2EXP(,"P04", P04->(RECNO()), "U" )
														
						ELSE
							cMsgErro:= "Falha ao mover arquivo para a Pasta Publicados"
						ENDIF				
					//ELSE                                                    
					//	cMsgErro	:= "Falha no UPLOAD do Arquivo(2): "+cPathOrig					
					//ENDIF	
				ELSE 
					cMsgErro	:= "Falha no UPLOAD do Arquivo: "+cPathOrig		
				ENDIF
	
	
			//Ŀ
			// Remove Arquivos 
			//                 				
			// 3=Remover       		
			// 4=Reprocessar   		
			//
			ELSEIF cOpc == "3" .OR. cOpc == "4"
		
				IF cOpc == "3" .AND. P04->P04_STATUS <> "2" //| Publicado
	                                         
					cMsgErro	:= "Acao nao permitida para o arquivo selecionado"
					
				//
				// Caso o status atual do registro seja igual a removido, somente     
				// altera status da tabela pois arquivos ja estao nas pastas corretas 
				//
				ELSEIF cOpc == "4" .AND. P04->P04_STATUS == "3" //| Removido
	
					RECLOCK("P04", .F.)
						P04->P04_STATUS	:= cOpc
						IF EMPTY(P04->P04_DTREM)
							P04->P04_DTREM 	:= DDATABASE
							P04->P04_HRREM	:= TIME()
						ENDIF
					MSUNLOCK()
									
					lRet	:= .T.		
					
					/*-----------------------------------
						PROTHEUS CONNECTOR 
						Remove arquivo do CRM
					-------------------------------------*/							
					U_PCON2EXP(,"P04", P04->(RECNO()), "U" )		
				ELSE
					
					cPathOrig	:= U_omPathPDF(P04->P04_STATUS)+alltrim(P04->P04_ARQUIV)
					cPathDest	:= U_omPathPDF(cOpc)+alltrim(P04->P04_ARQUIV)
						                                                                     
					//Ŀ
					// Somente exclui arquivo do FTP caso o mesmo esteja publicado 
					//
					IF IIF(P04->P04_STATUS=="2", FTPERASE( alltrim(P04->P04_ARQUIV) ), .T.)
						//Ŀ
						// Copia Arquivo para pasta Removidos  
						//
						__CopyFile(cPathOrig , cPathDest)
						
						IF FILE(cPathDest)
						
							//Ŀ
							// Desabilita visualizacao do arquivo no Portal 
							//	
							RECLOCK("P04", .F.)
								P04->P04_STATUS := cOpc   
								IF EMPTY(P04->P04_DTREM)
									P04->P04_DTREM 	:= DDATABASE
									P04->P04_HRREM	:= TIME()
								ENDIF							
							MSUNLOCK()
							
							lRet	:= .T.
							
							Ferase(cPathOrig)	//| Remove arquivo da pasta de origem	
							
							/*-----------------------------------
								PROTHEUS CONNECTOR 
								Remove arquivo do CRM
							-------------------------------------*/							
							U_PCON2EXP(,"P04", P04->(RECNO()), "U" )	
						ELSE
							cMsgErro	:= "Falha ao mover arquivo para a Pasta Removidos"
						ENDIF
					ELSE
						cMsgErro	:= "Falha ao remover arquivo do FTP "+alltrim(P04->P04_ARQUIV)
					ENDIF
				ENDIF
			ELSE
				cMsgErro	:= "Acao nao permitida para o arquivo selecionado"
			ENDIF   
	
			aadd(aRet, {lRet, aRecnoP04[nY], cMsgErro})	
		Next nY		
	ELSE
		cMsgErro	:= "Falha ao conectar ao FTP: "+cFTPURL    
		aadd(aRet, {.F., 0, cMsgErro})		
	ENDIF     
	FTPDISCONNECT()
	
	//Ŀ
	//Funo que envia WorkFlow para os clientes do aceite Sustentvel. Thiago Nascimento | Compila | 02/11/2013.
	//
	//u_WFSCSEND("2") //| Comentado Augusto Ribeiro|
	
	/*------------------------------------------------------ Augusto Ribeiro | 09/12/2015 - 2:54:41 PM
		Envio de e-mail com faturas em anexo.
	------------------------------------------------------------------------------------------*/
	IF cOpc == "2" //| Publicacao de arquivos|
		MsgRun ( "Enviando e-mail com faturas em anexo", "Faturas por e-mail. [U_WFFAT01S]", {|| U_WFFAT01S() } )
	ENDIF
	
ENDIF

RestArea(aAreaP04)
RestArea(aArea)
Return(aRet)




//Ŀ
// Retorna Path de Acordo com o Status passado 
//   
/*

ͻ
Programa   omPathPDFAutor  Augusto Ribeiro      Data  13/03/2010  
͹
Desc.      Retorno Path do PDF de acordo com o status do registro     
                                                                      
PARAMETROS cStatus     : Status                                       
                                                                      
RETORNO    cRet	:= Pth do PDF                  						  
ͼ

*/
User Function omPathPDF(cStatus)
Local cRet	:= ""
Local cDirGerado	:= U_AFAT151G("00", "PDFGERA")
Local cDirRemov		:= U_AFAT151G("00", "PDFREMO")
Local cDirPublic	:= U_AFAT151G("00", "PDFPUBL")


//Ŀ
// Gerado             
//	
IF cStatus == "1"
	
	cRet	:= cDirGerado
	
//Ŀ
// Publicado          
//
ELSEIF cStatus == "2"    

	cRet	:= cDirPublic	

//Ŀ
// Removido / Reprocessar 
//
ELSEIF cStatus == "3" .OR. cStatus == "4"

	cRet	:= cDirRemov		
ENDIF

cRet	:= ALLTRIM(cRet)

Return(cRet)



/*

ͻ
Programa  omGerExc  Autor  Augusto Ribeiro      Data  13/4/2015  
͹
Desc.     Imprime relatrio em Excel                                   
           *ATENCAO* - Necessario que o Action do rel. seja uma       
          User Function                                               
                                                                      
PARAMETROS oPrint      : Objeto do relatorio                          
           cPathName   : Caminho onde o PDF sera gerado               
           cNomeArq    : Nome do Arquivo                              
           cTipoRel    : Tipo de Relatorio TReport ou TMSPriter       
                                                                      
RETORNO    aRet{lRelOK, cLOG_ERRO, P05_STATUS}                        
           1=Nao Processado;2=Processado;3=Inconsistencia;4=Desconsid 
͹
Uso        Zatix.	                                                  
ͼ

*/
User Function omGerExc(oPrint, cPathName, cNomeArq, cPathServer,cTipoRel)
Local aChkFile 		:= {}
Local cArqIniPdf	:= ""
Local nOutFile		:= 0
Local cPrintPadrao	:= ""
Local aRet			:= {.F., "","3"}
Local cSession		:= GetPrinterSession()     
Local nY			:= 0
Local nTimeOut		:= 600 	//| Segundos

Local aPriters      

Local cPSConvert


Default cTipoRel	:= "TReport"   
Default cPathServer	:= cPathName

Private nHdlSemaf		:= 0	//| Semaforo
        
cTipoRel	:= UPPER(ALLTRIM(cTipoRel))			

CONOUT("********| INICIO - omGerExc - "+cPathName)
   

//Ŀ
// Define impressora com  orientacao do relatorio	   	 
//
IF oPrint:GetOrientation() == 1
//		WriteProfString( cSession , "ORIENTATION", "PORTRAIT", .T. )
ELSE
//		WriteProfString( cSession , "ORIENTATION", "LANDSCAPE", .T. ) 
ENDIF


IF cTipoRel == "TREPORT"			
	//Ŀ
	// Dispara impressao do Relatorio  
	//	
	oPrint:SetEnvironment("SERVER")	//| {"SERVER","CLIENT"}
	//oPrint:SetDevice("FILE")		//| {"FILE","SPOOL","PORT","EMAIL"}	
	oPrint:SetDevice(4) //| EXCEL 	
	oPrint:cFile	:= cPathName+cNomeArq
					
	oPrint:SetPreview(.F.) 
	oPrint:lParamPage	:= .F.	 
	//oPrint:LEMPTYLINEEXCEL	:= .F.	
	
	
	oPrint:Print()	
	
	//Ŀ
	// Verifica se o arquivo impresso est vazio 
	//
    IF oPrint:NXLSROW <= 5
        aRet	:= {.F., "Nao ha dados a serem exibidos.", "4"}
        IF FILE(cPathName+cNomeArq)
        	FERASE(cPathName+cNomeArq)
        ENDIF
    ELSE             
        aRet	:= {.T.,"","2"}
   		//Sleep(500)	//| 0,5 Segundos
 	ENDIF
	     
ENDIF		                                            		




CONOUT("********| FIM - omGerExc - "+cPathName)
 
Return(aRet) 